/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package LinkedList;

import org.junit.Test;

import javax.annotation.Nullable;
import java.util.ArrayList;

import static org.junit.Assert.*;

public class AppTest {

    //creating global variables to be used in subsequent testing. Strictly for ease of writing.
    String one = "one";
    String two = "two";
    String three = "three";
    String four = "four";

    //Testing instantiating an empty linked list, and adding one node.
    @Test
    public void testLinkedListHead() {
        //creating the empty list
        LinkedList testList = new LinkedList();
        //using the insert function to add a single node. I would expect that this node has a null reference.
        testList.insert(one);

        //asserting that the head exists, and has a reference of null.
        assertEquals(testList.head.reference, null);
        //asserting that the head exists, and has a value of one.
        assertEquals(testList.head.value, one);
    }

    //testing the insert function. If this is functioning properly, I would expect each new node to be added in the head
    //position of the list.
    @Test
    public void testInsert() {
        //create the empty linked list
        LinkedList testList = new LinkedList();
        //adding one node
        testList.insert(one);
        //setting that node as a variable called the endOfList, to be used in later tests.
        Object endOfList = testList.head;
        //adding a second node
        testList.insert(two);

        //asserting that the head references the endOfList. I would expect this to return true, as there are only two nodes
        //in the list at this point.
        assertEquals(testList.head.reference, endOfList);
        //asserting that the head value equals two.
        assertEquals(testList.head.value, two);

        //inserting a third node
        testList.insert(three);

        //asserting that the endOfList node has now moved down the reference chain by one.
        assertEquals(testList.head.reference.reference, endOfList);
        //asserting that the head.value is now three.
        assertEquals(testList.head.value, three);
    }

    //as this list is set up to accept Generic data types, I have replicated the insert tests with int's instead of strings
    //these follow the same pattern and reasoning as the above tests.
    @Test
    public void testInsertInt() {
        LinkedList testListInt = new LinkedList();
        testListInt.insert(1);

        Object endOfList = testListInt.head;

        testListInt.insert(2);

        assertEquals(testListInt.head.reference, endOfList);
        assertEquals(testListInt.head.value, 2);

        testListInt.insert(3);

        assertEquals(testListInt.head.reference.reference, endOfList);
        assertEquals(testListInt.head.value, 3);
    }

    //This test tests the includes search function, and ensures that it is returning the expected boolean for several
    //different cases.
    @Test
    public void testIncludes() {
        //create an empty linked list
        LinkedList testList = new LinkedList();
        //insert nodes one - four
        testList.insert(one);
        testList.insert(two);
        testList.insert(three);
        testList.insert(four);

        //I would expect that the test would return true for .includes(values one-four), and so have written out assertsTrue
        //tests to ensure that is the case here.
        assertTrue(testList.includes(one));
        assertTrue(testList.includes(two));
        assertTrue(testList.includes(three));
        assertTrue(testList.includes(four));
        //this assertFalse case is included to confirm that it will return false when it does not find the target value.
        assertFalse(testList.includes("Seven"));
    }

    //as this list is set up to accept Generic data types, I have replicated the includes tests with int's instead of strings
    //these follow the same pattern and reasoning as the above tests.
    @Test
    public void testIncludesInt() {
        LinkedList testListInt = new LinkedList();
        testListInt.insert(1);
        testListInt.insert(2);
        testListInt.insert(3);
        testListInt.insert(4);

        assertTrue(testListInt.includes(1));
        assertTrue(testListInt.includes(2));
        assertTrue(testListInt.includes(3));
        assertTrue(testListInt.includes(4));
        assertFalse(testListInt.includes(7));
    }

    //this test shows that when presented an empty linked list, the includes function will return false for any test value.
    @Test
    public void testEmptyIncludes() {
        //creating an empty linked list
        LinkedList testList = new LinkedList();

        //asserting that values "one", null, 0, and 1 will all return false
        assertFalse(testList.includes(one));
        assertFalse(testList.includes(null));
        assertFalse(testList.includes(0));
        assertFalse(testList.includes(1));
    }

    //to allow for testing, my print function returns an array list as well as System.out.println(arrayList)ing it.
    //this test only tests the return values, and so it is feasible that some interaction could alter the print values and
    //not the return values. This should be kept in mind when using this test to conduct root cause analysis, or other
    //debugging activity.
    @Test
    public void testPrint() {
        //instantiating an empty linked list
        LinkedList testList = new LinkedList();
        //inserting nodes with the values one - four.
        testList.insert(one);
        testList.insert(two);
        testList.insert(three);
        testList.insert(four);

        //instantiating an expectedReturn ArrayList for testing
        ArrayList<String> expectedReturn = new ArrayList<>();
        //inserting the values one-four in the same order they will return from the linked list.
        expectedReturn.add(four);
        expectedReturn.add(three);
        expectedReturn.add(two);
        expectedReturn.add(one);

        //asserting the return from the print() method matches the expectedReturn ArrayList.
        assertEquals(testList.print(), expectedReturn);

    }

    //as this list is set up to accept Generic data types, I have replicated the print tests with int's instead of strings
    //these follow the same pattern and reasoning as the above tests.
    @Test
    public void testPrintInt() {
        LinkedList testListInt = new LinkedList();
        testListInt.insert(1);
        testListInt.insert(2);
        testListInt.insert(3);
        testListInt.insert(4);

        ArrayList<Integer> expectedReturn = new ArrayList<>();
        expectedReturn.add(4);
        expectedReturn.add(3);
        expectedReturn.add(2);
        expectedReturn.add(1);

        assertEquals(testListInt.print(), expectedReturn);

    }

    //this test is designed to show that a test print will return an empty array list.
    @Test
    public void testEmptyPrint() {
        //creating an empty linked list
        LinkedList testList = new LinkedList();

        //creating an empty Array List for comparison
        ArrayList<String> emptyReturn = new ArrayList<>();

        //asserting that the emptyReturn Array List matches the return from the .print() on the empty testList
        assertEquals(emptyReturn, testList.print());
    }


    //test the append function. I would expect this to insert a node on the null side of the list, so that it's refrence becomes null.
    @Test
    public void testAppend() {
        //create an empty linked list
        LinkedList testList = new LinkedList();

        //insert nodes with values one and two
        testList.insert(one);
        testList.insert(two);
        //append a node with the value three
        testList.append(three);

        //check that the final value in the linked list has a value of three
        assertEquals(three, testList.head.reference.reference.value);
        //check that the reference of the final node in the list is null
        assertEquals(null, testList.head.reference.reference.reference);
    }

    //this replicates the tests above, but uses int's and only insert's a single value before taking on an append.
    //it is designed to prove that the append method only needs one node inserted prior to it becoming a viable option.
    @Test
    public void testSingleAppend() {
        //create an empty linked list
        LinkedList testSingleList = new LinkedList();

        //insert a single value
        testSingleList.insert(1);

        //append an int
        testSingleList.append(2);

        assertEquals(2, testSingleList.head.reference.value);
        assertEquals(null, testSingleList.head.reference.reference);
    }

    @Test
    public void testMultiAppend() {
        //create an empty linked list and insert a single node
        LinkedList testMultiList = new LinkedList();
        testMultiList.insert(one);

        //append three subsequent values, testing that each has a refrence of null as we go.
        testMultiList.append(two);
        assertEquals(null, testMultiList.head.reference.reference);
        assertEquals(two, testMultiList.head.reference.value);

        testMultiList.append(three);
        assertEquals(null, testMultiList.head.reference.reference.reference);
        assertEquals(three, testMultiList.head.reference.reference.value);

        testMultiList.append(four);
        assertEquals(null, testMultiList.head.reference.reference.reference.reference);
        assertEquals(four, testMultiList.head.reference.reference.reference.value);
    }

    //the append function is intended to be used once a list already has nodes, and so I wanted to demonstrate what happens
    //when you try and append to an empty list.
    @Test
    public void testEmptyAppend() {
        //create an empty linked list
        LinkedList testEmptyList = new LinkedList();

        try {
            //append a value to the empty list
            testEmptyList.append(one);

            //as the append is designed to be used with a extant list, where it will insert to the end
            //I would expect this to throw a null pointer exception.
        } catch (NullPointerException ex) {

            //if this function is running correctly, it will throw a null pointer exception when you try to append to an
            //empty list. In this case, I may suggest using the insert method to create a head.
            assertTrue(ex instanceof NullPointerException);
        }
    }

    //the insertBefore method takes in a node value and target value, searches for the target value, and inserts the
    //node value as a new node on the head side of the list of the target value.
    @Test
    public void testInsertBefore() {
        LinkedList testList = new LinkedList();
        testList.insert(one);
        testList.insert(two);
        testList.insertBefore(three, one);

        assertTrue(testList.includes(three));
        assertEquals(three, testList.head.reference.value);
    }

    //the insertAfter method takes in a node value and target value, searches for the target value, and inserts the
    //node value as a new node on the null side of the list of the target value.
    @Test
    public void testInsertAfter() {
        LinkedList testList = new LinkedList();
        testList.insert(one);
        testList.insert(two);
        testList.insertAfter(three, one);

        assertTrue(testList.includes(three));
        assertEquals(three, testList.head.reference.reference.value);
    }


}
